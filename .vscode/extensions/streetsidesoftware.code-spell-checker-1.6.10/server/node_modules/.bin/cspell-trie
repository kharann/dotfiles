#!/usr/bin/env node --max_old_space_size=8192
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const commander = require("commander");
const fs = require("fs");
const cspell_lib_1 = require("cspell-lib");
const rxjs_stream_1 = require("rxjs-stream");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const fs_extra_1 = require("fs-extra");
const path = require("path");
const Trie = require("./lib");
const packageInfo = require('../package.json');
const version = packageInfo['version'];
commander
    .version(version);
commander
    .command('create <file.txt>')
    .option('-o, --output <file>', 'output file - defaults to stdout')
    .option('-l, --lower_case', 'output in lower case')
    .option('-b, --base <number>', 'Use base n for reference ids.  Defaults to 32. Common values are 10, 16, 32. Max of 36')
    .description('Generate a file for use with cspell')
    .action((filename, options) => {
    const { output: outputFile, lower_case: lowerCase = false, base = 32, } = options;
    notify('Create Trie', !!outputFile);
    const pOutputStream = createWriteStream(outputFile);
    notify(`Generating...`, !!outputFile);
    const rxReader = cspell_lib_1.lineReaderRx(filename, 'utf8');
    const toLower = lowerCase ? (a) => a.toLowerCase() : (a) => a;
    const wordsRx = rxReader.pipe(operators_1.map(toLower), operators_1.map(a => a.trim()), operators_1.filter(a => !!a));
    const trieRx = wordsRx.pipe(operators_1.reduce((node, word) => Trie.insert(word, node), {}), operators_1.tap(() => notify('Processing Trie')), operators_1.tap(() => notify('Export Trie')), operators_1.map(root => Trie.serializeTrie(root, (base - 0) || 32)), operators_1.flatMap(seq => rxjs_1.from(seq)));
    pOutputStream.then(writeStream => {
        rxjs_stream_1.rxToStream(trieRx.pipe(operators_1.bufferCount(1024), operators_1.map(words => words.join('')))).pipe(writeStream);
    });
});
commander
    .command('reader <file.trie>')
    .option('-o, --output <file>', 'output file - defaults to stdout')
    .description('Read a cspell trie file and output the list of words.')
    .action((filename, options) => {
    const { output: outputFile, } = options;
    notify('Reading Trie', !!outputFile);
    const pOutputStream = createWriteStream(outputFile);
    const rxReader = cspell_lib_1.lineReaderRx(filename, 'utf8');
    const wordsRx = Trie.importTrieRx(rxReader).pipe(operators_1.map(root => Trie.iteratorTrieWords(root)), operators_1.flatMap(seq => rxjs_1.from(seq)), operators_1.map(word => word + '\n'));
    pOutputStream.then(writeStream => {
        rxjs_stream_1.rxToStream(wordsRx.pipe(operators_1.bufferCount(1024), operators_1.map(words => words.join('')))).pipe(writeStream);
    });
});
commander.parse(process.argv);
if (!commander.args.length) {
    commander.help();
}
function createWriteStream(filename) {
    return !filename
        ? Promise.resolve(process.stdout)
        : fs_extra_1.mkdirp(path.dirname(filename)).then(() => fs.createWriteStream(filename));
}
function notify(message, useStdOut = true) {
    if (useStdOut) {
        console.log(message);
    }
    else {
        console.error(message);
    }
}
//# sourceMappingURL=app.js.map