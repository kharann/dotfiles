"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// cSpell:ignore curr
// cSpell:words zlib iconv
// cSpell:enableCompoundWords
const fs = require("fs");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const iconv = require("iconv-lite");
const zlib = require("zlib");
const readline = require("readline");
const defaultEncoding = 'utf8';
/**
 * Reads a file line by line. The last value emitted by the Observable is always an empty string.
 * @param filename
 * @param encoding defaults to 'utf8'
 */
function lineReaderRx(filename, encoding) {
    return stringsToLinesRx(textFileStreamRx(filename, encoding));
}
exports.lineReaderRx = lineReaderRx;
function prepareFileStream(filename, encoding, fnError) {
    const pipes = [];
    if (filename.match(/\.gz$/i)) {
        pipes.push(zlib.createGunzip());
    }
    pipes.push(iconv.decodeStream(encoding));
    const fileStream = fs.createReadStream(filename);
    fileStream.on('error', fnError);
    const stream = pipes.reduce((s, p) => s.pipe(p).on('error', fnError), fileStream);
    return stream;
}
function textFileStreamRx(filename, encoding = defaultEncoding) {
    const subject = new rxjs_1.Subject();
    const fnError = (e) => subject.error(e);
    const fnComplete = () => subject.complete();
    const stream = prepareFileStream(filename, encoding, fnError);
    stream.on('end', fnComplete);
    stream.on('data', s => subject.next(s));
    return subject;
}
exports.textFileStreamRx = textFileStreamRx;
/**
 * Emit a file line by line
 * @param filename full path to the file to read.
 * @param encoding defaults to 'utf8'
 */
function streamFileLineByLineRx(filename, encoding = defaultEncoding) {
    const subject = new rxjs_1.Subject();
    let data = '.';
    const fnError = (e) => subject.error(e);
    const fnComplete = () => {
        // readline will consume the last newline without emitting an empty last line.
        // If the last data read contains a new line, then emit an empty string.
        if (data.match(/(?:(?:\r?\n)|(?:\r))$/)) {
            subject.next('');
        }
        subject.complete();
    };
    const stream = prepareFileStream(filename, encoding, fnError);
    // We want to capture the last line.
    stream.on('data', d => data = d);
    const rl = readline.createInterface({
        input: stream,
        terminal: false,
    });
    rl.on('close', fnComplete);
    rl.on('line', (text) => subject.next(text));
    return subject;
}
exports.streamFileLineByLineRx = streamFileLineByLineRx;
function stringsToLinesRx(strings) {
    return rxjs_1.concat(strings, rxjs_1.of('\n')).pipe(operators_1.scan((last, curr) => {
        const parts = (last.remainder + curr).split(/\r?\n/);
        const lines = parts.slice(0, -1);
        const remainder = parts.slice(-1)[0];
        return { lines, remainder };
    }, { lines: [], remainder: '' }), operators_1.concatMap(emit => emit.lines));
}
exports.stringsToLinesRx = stringsToLinesRx;
//# sourceMappingURL=fileReader.js.map