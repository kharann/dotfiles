"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const stream = require("stream");
/**
 * Transform the output of an Observable into a node readable stream.
 */
function rxToStream(src, options = { encoding: 'utf8' }, onError) {
    const trigger = new rxjs_1.Subject();
    let depth = 0;
    const maxDepth = 100;
    const readable = new stream.Readable(Object.assign({}, options, { read: () => {
            trigger.next();
        } }));
    function close(err) {
        try {
            if (err && onError)
                onError(err, readable);
        }
        finally {
            rxjs_1.interval(1).pipe(operators_1.take(1)).subscribe(() => readable.push(null));
        }
    }
    function next() {
        if (depth < maxDepth) {
            // Use the fastest method
            trigger.next();
        }
        else {
            // Slower to avoid running out of stack space.
            rxjs_1.interval().pipe(operators_1.take(1)).subscribe(() => trigger.next());
        }
    }
    function push(data) {
        depth += 1;
        readable.push(data) ? next() : null;
        depth -= 1;
    }
    trigger
        // Use zip to buffer the Observable so we only send when the stream is ready.
        .pipe(operators_1.zip(src, (_, src) => src))
        .subscribe(
    // send the data and signal we can use more data.
    push, 
    // Close on error or complete.
    close, close);
    return readable;
}
exports.rxToStream = rxToStream;
//# sourceMappingURL=rxToStream.js.map