#!/usr/bin/env node --max_old_space_size=8192
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const commander = require("commander");
const HunspellReader_1 = require("./HunspellReader");
const fs = require("fs");
const rxjs_stream_1 = require("rxjs-stream");
const fs_extra_1 = require("fs-extra");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const path = require("path");
// import * as monitor from './monitor';
const packageInfo = require('../package.json');
const version = packageInfo['version'];
commander
    .version(version);
commander
    .command('words <hunspell_dic_file>')
    .option('-o, --output <file>', 'output file - defaults to stdout')
    .option('-s, --sort', 'sort the list of words')
    .option('-u, --unique', 'make sure the words are unique.')
    .option('-i, --ignore_case', 'used with --unique and --sort')
    .option('-l, --lower_case', 'output in lower case')
    .option('-T, --no-transform', 'Do not apply the prefix and suffix transforms.  Root words only.')
    .description('Output all the words in the <hunspell.dic> file.')
    .action((hunspellDicFilename, options) => {
    const { sort = false, unique = false, ignore_case: ignoreCase = false, output: outputFile, lower_case: lowerCase = false, transform = true, } = options;
    notify('Write words', !!outputFile);
    notify(`Sort: ${yesNo(sort)}`, !!outputFile);
    notify(`Unique: ${yesNo(unique)}`, !!outputFile);
    notify(`Ignore Case: ${yesNo(ignoreCase)}`, !!outputFile);
    const pOutputStream = createWriteStream(outputFile);
    const baseFile = hunspellDicFilename.replace(/(\.dic)?$/, '');
    const dicFile = baseFile + '.dic';
    const affFile = baseFile + '.aff';
    notify(`Dic file: ${dicFile}`, !!outputFile);
    notify(`Aff file: ${affFile}`, !!outputFile);
    notify(`Generating Words`, !!outputFile);
    const pReader = HunspellReader_1.HunspellReader.createFromFiles(affFile, dicFile);
    const pWordReader = transform ? pReader.then(reader => reader.readWords()) : pReader.then(reader => reader.readRootWords());
    const wordsRx = rxjs_1.from(pWordReader).pipe(operators_1.map(words => words.pipe(operators_1.map(a => a.trim()), operators_1.filter(a => !!a))), operators_1.map(wordsRx => unique ? makeUnique(wordsRx, ignoreCase) : wordsRx), operators_1.map(wordsRx => sort ? sortWordList(wordsRx, ignoreCase) : wordsRx), operators_1.map(wordsRx => lowerCase ? wordsRx.pipe(operators_1.map(a => a.toLowerCase())) : wordsRx), operators_1.flatMap(words => words), operators_1.map(word => word + '\n'));
    pOutputStream.then(writeStream => {
        rxjs_stream_1.rxToStream(wordsRx.pipe(operators_1.bufferCount(1024), operators_1.map(words => words.join('')))).pipe(writeStream);
    });
});
commander.parse(process.argv);
if (!commander.args.length) {
    commander.help();
}
function createWriteStream(filename) {
    return !filename
        ? Promise.resolve(process.stdout)
        : fs_extra_1.mkdirp(path.dirname(filename)).then(() => fs.createWriteStream(filename));
}
function sortWordList(words, ignoreCase) {
    const compStr = (a, b) => a < b ? -1 : (a > b ? 1 : 0);
    const fnComp = ignoreCase
        ? ((a, b) => compStr(a.toLowerCase(), b.toLowerCase()))
        : compStr;
    return words.pipe(operators_1.toArray(), operators_1.flatMap(a => a.sort(fnComp)));
}
function makeUnique(words, ignoreCase) {
    const found = new Set();
    const normalize = ignoreCase ? (a => a.toLowerCase()) : (a => a);
    return words.pipe(operators_1.filter(w => !found.has(normalize(w))), operators_1.tap(w => found.add(normalize(w))));
}
function notify(message, useStdOut = true) {
    if (useStdOut) {
        console.log(message);
    }
    else {
        console.error(message);
    }
}
function yesNo(value) {
    return value ? 'Yes' : 'No';
}
//# sourceMappingURL=app.js.map