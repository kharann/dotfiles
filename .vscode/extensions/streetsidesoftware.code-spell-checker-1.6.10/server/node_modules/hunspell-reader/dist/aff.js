"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util = require("util");
const converter_1 = require("./converter");
const gensequence_1 = require("gensequence");
const GS = require("gensequence");
// cSpell:enableCompoundWords
const log = false;
;
class Aff {
    constructor(affInfo) {
        this.affInfo = affInfo;
        this.rules = processRules(affInfo);
        this._iConv = new converter_1.Converter(affInfo.ICONV || []);
        this._oConv = new converter_1.Converter(affInfo.OCONV || []);
    }
    /**
     * Takes a line from a hunspell.dic file and applies the rules found in the aff file.
     * @param {string} line - the line from the .dic file.
     */
    applyRulesToDicEntry(line) {
        const [lineLeft] = line.split(/\s+/, 1);
        const [word, rules = ''] = lineLeft.split('/', 2);
        return this.applyRulesToWord({ word, rules, flags: {}, rulesApplied: '' })
            .map(affWord => (Object.assign({}, affWord, { word: this._oConv.convert(affWord.word) })));
    }
    /**
     * @internal
     */
    applyRulesToWord(affWord) {
        const { word } = affWord;
        const allRules = this.getMatchingRules(affWord.rules);
        const { rulesApplied, flags } = allRules
            .filter(rule => !!rule.flags)
            .reduce((acc, rule) => ({
            rulesApplied: [acc.rulesApplied, rule.id].join(' '),
            flags: Object.assign({}, acc.flags, rule.flags),
        }), { rulesApplied: affWord.rulesApplied, flags: affWord.flags });
        const rules = allRules.filter(rule => !rule.flags).map(rule => rule.id).join('');
        const affixRules = allRules.map(rule => rule.sfx || rule.pfx).filter(a => !!a);
        const wordWithFlags = { word, flags, rulesApplied, rules: '' };
        return [
            wordWithFlags,
            ...this.applyAffixesToWord(affixRules, Object.assign({}, wordWithFlags, { rules }))
        ]
            .filter(({ flags }) => !flags.isNeedAffix)
            .map(affWord => logAffWord(affWord, 'applyRulesToWord'));
    }
    applyAffixesToWord(affixRules, affWord) {
        const combinableSfx = affixRules
            .filter(rule => rule.type === 'SFX')
            .filter(rule => rule.combinable === true)
            .map(({ id }) => id)
            .join('');
        const r = affixRules
            .map(affix => this.applyAffixToWord(affix, affWord, combinableSfx))
            .reduce((a, b) => a.concat(b), [])
            .map(affWord => this.applyRulesToWord(affWord))
            .reduce((a, b) => a.concat(b), []);
        return r;
    }
    applyAffixToWord(affix, affWord, combinableSfx) {
        const { word } = affWord;
        const combineRules = (affix.type === 'PFX' && affix.combinable && !!combinableSfx)
            ? combinableSfx
            : '';
        const flags = Object.assign({}, affWord.flags, { isNeedAffix: false });
        return [...affix.substitutionSets.values()]
            .filter(sub => sub.match.test(word))
            .map(sub => sub.substitutions)
            .reduce((a, b) => a.concat(b), [])
            .filter(sub => sub.replace.test(word))
            .map(sub => ({
            word: word.replace(sub.replace, sub.attach),
            rulesApplied: [affWord.rulesApplied, affix.id].join(' '),
            rules: combineRules + (sub.attachRules || ''),
            flags
        }))
            .map(affWord => logAffWord(affWord, 'applyAffixToWord'));
    }
    getMatchingRules(rules) {
        const { AF = [] } = this.affInfo;
        const rulesToSplit = AF[rules] || rules;
        return this.separateRules(rulesToSplit)
            .map(key => this.rules[key])
            .filter(a => !!a);
    }
    separateRules(rules) {
        if (this.affInfo.FLAG === 'long') {
            return rules.replace(/(..)/g, '$1//').split('//').slice(0, -1);
        }
        else {
            return rules.split('');
        }
    }
    get iConv() {
        return this._iConv;
    }
    get oConv() {
        return this._oConv;
    }
}
exports.Aff = Aff;
function processRules(affInfo) {
    const sfxRules = gensequence_1.genSequence(affInfo.SFX || []).map(([, sfx]) => sfx).map(sfx => ({ id: sfx.id, type: 'sfx', sfx }));
    const pfxRules = gensequence_1.genSequence(affInfo.PFX || []).map(([, pfx]) => pfx).map(pfx => ({ id: pfx.id, type: 'pfx', pfx }));
    const flagRules = GS.sequenceFromObject(affInfo)
        .filter(([key, value]) => !!affFlag[key] && !!value)
        .map(([key, value]) => ({ id: value, type: 'flag', flags: affFlag[key] }));
    const rules = sfxRules.concat(pfxRules).concat(flagRules)
        .reduce((acc, rule) => { acc[rule.id] = rule; return acc; }, new Map());
    return rules;
}
exports.processRules = processRules;
const affFlag = {
    KEEPCASE: { isKeepCase: true },
    WARN: { isWarning: true },
    FORCEUCASE: { isForceUCase: true },
    FORBIDDENWORD: { isForbiddenWord: true },
    NOSUGGEST: { isNoSuggest: true },
    NEEDAFFIX: { isNeedAffix: true },
    COMPOUNDBEGIN: { canBeCompoundBegin: true },
    COMPOUNDMIDDLE: { canBeCompoundMiddle: true },
    COMPOUNDEND: { canBeCompoundEnd: true },
    COMPOUNDPERMITFLAG: { isCompoundPermitted: true },
    ONLYINCOMPOUND: { isOnlyAllowedInCompound: true },
};
const flagToStringMap = {
    isCompoundPermitted: 'C',
    canBeCompoundBegin: 'B',
    canBeCompoundMiddle: 'M',
    canBeCompoundEnd: 'E',
    isOnlyAllowedInCompound: 'O',
    isWarning: 'W',
    isKeepCase: 'K',
    isForceUCase: 'U',
    isForbiddenWord: 'F',
    isNoSuggest: 'N',
    isNeedAffix: 'A',
};
function logAffWord(affWord, message) {
    /* istanbul ignore if */
    if (log) {
        const dump = util.inspect(affWord, { showHidden: false, depth: 5, colors: true });
        console.log(`${message}: ${dump}`);
    }
    return affWord;
}
exports.logAffWord = logAffWord;
/* istanbul ignore next */
function affWordToColoredString(affWord) {
    return util.inspect(Object.assign({}, affWord, { flags: flagsToString(affWord.flags) }), { showHidden: false, depth: 5, colors: true }).replace(/(\s|\n|\r)+/g, ' ');
}
exports.affWordToColoredString = affWordToColoredString;
/* istanbul ignore next */
function flagsToString(flags) {
    return GS.sequenceFromObject(flags)
        .filter(([, v]) => !!v)
        // convert the key to a string
        .map(([k]) => flagToStringMap[k])
        .toArray()
        .sort()
        .join('_');
}
exports.flagsToString = flagsToString;
//# sourceMappingURL=aff.js.map