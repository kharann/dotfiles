{"version":3,"sources":["../../webpack/bootstrap","../../external \"util\"","../../external \"stream\"","../../external \"events\"","../../external \"path\"","../../external \"fs\"","../../external \"zlib\"","../.././node_modules/node-stream-zip/node_stream_zip.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","util","fs","path","events","zlib","stream","consts","LOCHDR","LOCSIG","LOCVER","LOCFLG","LOCHOW","LOCTIM","LOCCRC","LOCSIZ","LOCLEN","LOCNAM","LOCEXT","EXTSIG","EXTHDR","EXTCRC","EXTSIZ","EXTLEN","CENHDR","CENSIG","CENVEM","CENVER","CENFLG","CENHOW","CENTIM","CENCRC","CENSIZ","CENLEN","CENNAM","CENEXT","CENCOM","CENDSK","CENATT","CENATX","CENOFF","ENDHDR","ENDSIG","ENDSIGFIRST","ENDSUB","ENDTOT","ENDSIZ","ENDOFF","ENDCOM","MAXFILECOMMENT","ENDL64HDR","ENDL64SIG","ENDL64SIGFIRST","ENDL64OFS","END64HDR","END64SIG","END64SIGFIRST","END64SUB","END64TOT","END64SIZ","END64OFF","STORED","SHRUNK","REDUCED1","REDUCED2","REDUCED3","REDUCED4","IMPLODED","DEFLATED","ENHANCED_DEFLATED","PKWARE","BZIP2","LZMA","IBM_TERSE","IBM_LZ77","FLG_ENC","FLG_COMP1","FLG_COMP2","FLG_DESC","FLG_ENH","FLG_STR","FLG_LNG","FLG_MSK","FLG_ENTRY_ENC","EF_ID","EF_SIZE","ID_ZIP64","ID_AVINFO","ID_PFS","ID_OS2","ID_NTFS","ID_OPENVMS","ID_UNIX","ID_FORK","ID_PATCH","ID_X509_PKCS7","ID_X509_CERTID_F","ID_X509_CERTID_C","ID_STRONGENC","ID_RECORD_MGT","ID_X509_PKCS7_RL","ID_IBM1","ID_IBM2","ID_POSZIP","EF_ZIP64_OR_32","EF_ZIP64_OR_16","StreamZip","config","fd","fileSize","chunkSize","op","centralDirectory","that","this","entries","storeEntries","fileName","file","readUntilFoundCallback","err","bytesRead","emit","buffer","win","pos","lastPos","bufferPosition","position","minPos","length","firstByte","readUInt32LE","sig","lastBufferPosition","lastBytesRead","complete","expandLength","Math","min","expandLeft","readCentralDirectoryComplete","CentralDirectoryHeader","read","slice","headerOffset","commentLength","comment","toString","entriesCount","volumeEntries","totalEntries","size","offset","readZip64CentralDirectoryLocatorComplete","totalReadLength","readZip64CentralDirectoryLocator","readEntries","locHeader","CentralDirectoryLoc64Header","readLength","readZip64CentralDirectoryComplete","zip64cd","CentralDirectoryZip64Header","FileWindowBuffer","entriesLeft","readEntriesCallback","bufferPos","bufferLength","entry","ZipEntry","readHeader","entryHeaderSize","fnameLen","extraLen","comLen","moveRight","move","skipEntryNameValidation","validateName","checkEntriesExist","Error","dataOffset","canVerifyCrc","flags","extract","outPath","callback","stm","fsStm","errThrown","on","unpipe","close","open","fdFile","createWriteStream","pipe","extractFiles","baseDir","baseRelPath","files","extractedCount","shift","join","replace","f","fstat","stat","round","max","readCentralDirectory","openEntry","entryStream","EntryDataReaderStream","compressedSize","method","createInflateRaw","EntryVerifyStream","crc","entryDataSync","e","en","data","Buffer","FsRead","br","inflateRawSync","CrcVerify","sync","isFile","readEx","readDataHeader","encrypted","ex","entryName","isDirectory","dirs","allDirs","lastIndexOf","relPath","childEntry","push","dirname","parts","split","filter","partsPath","sort","x","y","createDirectories","dir","apply","mkdir","code","basename","setFs","customFs","inherits","EventEmitter","readUInt16LE","Util","readUInt64LE","verMade","version","time","diskStart","inattr","attr","lastChar","readExtra","test","signature","maxPos","parseZip64Extra","waiting","debug","console","log","readSync","readCallback","fsOp","checkOp","concat","expandRight","copy","Readable","constructor","_read","baseStm","Transform","verify","_transform","encoding","state","crcTable","getCrcTable","off","len","buf","writeInt32LE","b","k"],"mappings":"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","file":"node_modules/node-stream-zip.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 880);\n","module.exports = require(\"util\");","module.exports = require(\"stream\");","module.exports = require(\"events\");","module.exports = require(\"path\");","module.exports = require(\"fs\");","module.exports = require(\"zlib\");","/**\n * @license node-stream-zip | (c) 2015 Antelle | https://github.com/antelle/node-stream-zip/blob/master/MIT-LICENSE.txt\n * Portions copyright https://github.com/cthackers/adm-zip | https://raw.githubusercontent.com/cthackers/adm-zip/master/MIT-LICENSE.txt\n */\n\n// region Deps\n\nvar\n    util = require('util'),\n    fs = require('fs'),\n    path = require('path'),\n    events = require('events'),\n    zlib = require('zlib'),\n    stream = require('stream');\n\n// endregion\n\n// region Constants\n\nvar consts = {\n    /* The local file header */\n    LOCHDR           : 30, // LOC header size\n    LOCSIG           : 0x04034b50, // \"PK\\003\\004\"\n    LOCVER           : 4, // version needed to extract\n    LOCFLG           : 6, // general purpose bit flag\n    LOCHOW           : 8, // compression method\n    LOCTIM           : 10, // modification time (2 bytes time, 2 bytes date)\n    LOCCRC           : 14, // uncompressed file crc-32 value\n    LOCSIZ           : 18, // compressed size\n    LOCLEN           : 22, // uncompressed size\n    LOCNAM           : 26, // filename length\n    LOCEXT           : 28, // extra field length\n\n    /* The Data descriptor */\n    EXTSIG           : 0x08074b50, // \"PK\\007\\008\"\n    EXTHDR           : 16, // EXT header size\n    EXTCRC           : 4, // uncompressed file crc-32 value\n    EXTSIZ           : 8, // compressed size\n    EXTLEN           : 12, // uncompressed size\n\n    /* The central directory file header */\n    CENHDR           : 46, // CEN header size\n    CENSIG           : 0x02014b50, // \"PK\\001\\002\"\n    CENVEM           : 4, // version made by\n    CENVER           : 6, // version needed to extract\n    CENFLG           : 8, // encrypt, decrypt flags\n    CENHOW           : 10, // compression method\n    CENTIM           : 12, // modification time (2 bytes time, 2 bytes date)\n    CENCRC           : 16, // uncompressed file crc-32 value\n    CENSIZ           : 20, // compressed size\n    CENLEN           : 24, // uncompressed size\n    CENNAM           : 28, // filename length\n    CENEXT           : 30, // extra field length\n    CENCOM           : 32, // file comment length\n    CENDSK           : 34, // volume number start\n    CENATT           : 36, // internal file attributes\n    CENATX           : 38, // external file attributes (host system dependent)\n    CENOFF           : 42, // LOC header offset\n\n    /* The entries in the end of central directory */\n    ENDHDR           : 22, // END header size\n    ENDSIG           : 0x06054b50, // \"PK\\005\\006\"\n    ENDSIGFIRST      : 0x50,\n    ENDSUB           : 8, // number of entries on this disk\n    ENDTOT           : 10, // total number of entries\n    ENDSIZ           : 12, // central directory size in bytes\n    ENDOFF           : 16, // offset of first CEN header\n    ENDCOM           : 20, // zip file comment length\n    MAXFILECOMMENT   : 0xFFFF,\n\n    /* The entries in the end of ZIP64 central directory locator */\n    ENDL64HDR       : 20, // ZIP64 end of central directory locator header size\n    ENDL64SIG       : 0x07064b50, // ZIP64 end of central directory locator signature\n    ENDL64SIGFIRST  : 0x50,\n    ENDL64OFS       : 8, // ZIP64 end of central directory offset\n\n    /* The entries in the end of ZIP64 central directory */\n    END64HDR        : 56, // ZIP64 end of central directory header size\n    END64SIG        : 0x06064b50, // ZIP64 end of central directory signature\n    END64SIGFIRST   : 0x50,\n    END64SUB        : 24, // number of entries on this disk\n    END64TOT        : 32, // total number of entries\n    END64SIZ        : 40,\n    END64OFF        : 48,\n\n    /* Compression methods */\n    STORED           : 0, // no compression\n    SHRUNK           : 1, // shrunk\n    REDUCED1         : 2, // reduced with compression factor 1\n    REDUCED2         : 3, // reduced with compression factor 2\n    REDUCED3         : 4, // reduced with compression factor 3\n    REDUCED4         : 5, // reduced with compression factor 4\n    IMPLODED         : 6, // imploded\n    // 7 reserved\n    DEFLATED         : 8, // deflated\n    ENHANCED_DEFLATED: 9, // enhanced deflated\n    PKWARE           : 10,// PKWare DCL imploded\n    // 11 reserved\n    BZIP2            : 12, //  compressed using BZIP2\n    // 13 reserved\n    LZMA             : 14, // LZMA\n    // 15-17 reserved\n    IBM_TERSE        : 18, // compressed using IBM TERSE\n    IBM_LZ77         : 19, //IBM LZ77 z\n\n    /* General purpose bit flag */\n    FLG_ENC          : 0,  // encrypted file\n    FLG_COMP1        : 1,  // compression option\n    FLG_COMP2        : 2,  // compression option\n    FLG_DESC         : 4,  // data descriptor\n    FLG_ENH          : 8,  // enhanced deflation\n    FLG_STR          : 16, // strong encryption\n    FLG_LNG          : 1024, // language encoding\n    FLG_MSK          : 4096, // mask header values\n    FLG_ENTRY_ENC    : 1,\n\n    /* 4.5 Extensible data fields */\n    EF_ID            : 0,\n    EF_SIZE          : 2,\n\n    /* Header IDs */\n    ID_ZIP64         : 0x0001,\n    ID_AVINFO        : 0x0007,\n    ID_PFS           : 0x0008,\n    ID_OS2           : 0x0009,\n    ID_NTFS          : 0x000a,\n    ID_OPENVMS       : 0x000c,\n    ID_UNIX          : 0x000d,\n    ID_FORK          : 0x000e,\n    ID_PATCH         : 0x000f,\n    ID_X509_PKCS7    : 0x0014,\n    ID_X509_CERTID_F : 0x0015,\n    ID_X509_CERTID_C : 0x0016,\n    ID_STRONGENC     : 0x0017,\n    ID_RECORD_MGT    : 0x0018,\n    ID_X509_PKCS7_RL : 0x0019,\n    ID_IBM1          : 0x0065,\n    ID_IBM2          : 0x0066,\n    ID_POSZIP        : 0x4690,\n\n    EF_ZIP64_OR_32   : 0xffffffff,\n    EF_ZIP64_OR_16   : 0xffff\n};\n\n// endregion\n\n// region StreamZip\n\nvar StreamZip = function(config) {\n    var\n        fd,\n        fileSize,\n        chunkSize,\n        ready = false,\n        that = this,\n        op,\n        centralDirectory,\n\n        entries = config.storeEntries !== false ? {} : null,\n        fileName = config.file;\n\n    open();\n\n    function open() {\n        fs.open(fileName, 'r', function(err, f) {\n            if (err)\n                return that.emit('error', err);\n            fd = f;\n            fs.fstat(fd, function(err, stat) {\n                if (err)\n                    return that.emit('error', err);\n                fileSize = stat.size;\n                chunkSize = config.chunkSize || Math.round(fileSize / 1000);\n                chunkSize = Math.max(Math.min(chunkSize, Math.min(128*1024, fileSize)), Math.min(1024, fileSize));\n                readCentralDirectory();\n            });\n        });\n    }\n\n    function readUntilFoundCallback(err, bytesRead) {\n        if (err || !bytesRead)\n            return that.emit('error', err || 'Archive read error');\n        var\n            buffer = op.win.buffer,\n            pos = op.lastPos,\n            bufferPosition = pos - op.win.position,\n            minPos = op.minPos;\n        while (--pos >= minPos && --bufferPosition >= 0) {\n            if (buffer.length - bufferPosition >= 4 &&\n                buffer[bufferPosition] === op.firstByte) { // quick check first signature byte\n                if (buffer.readUInt32LE(bufferPosition) === op.sig) {\n                    op.lastBufferPosition = bufferPosition;\n                    op.lastBytesRead = bytesRead;\n                    op.complete();\n                    return;\n                }\n            }\n        }\n        if (pos === minPos) {\n            return that.emit('error', 'Bad archive');\n        }\n        op.lastPos = pos + 1;\n        op.chunkSize *= 2;\n        if (pos <= minPos)\n            return that.emit('error', 'Bad archive');\n        var expandLength = Math.min(op.chunkSize, pos - minPos);\n        op.win.expandLeft(expandLength, readUntilFoundCallback);\n\n    }\n\n    function readCentralDirectory() {\n        var totalReadLength = Math.min(consts.ENDHDR + consts.MAXFILECOMMENT, fileSize);\n        op = {\n            win: new FileWindowBuffer(fd),\n            totalReadLength: totalReadLength,\n            minPos: fileSize - totalReadLength,\n            lastPos: fileSize,\n            chunkSize: Math.min(1024, chunkSize),\n            firstByte: consts.ENDSIGFIRST,\n            sig: consts.ENDSIG,\n            complete: readCentralDirectoryComplete\n        };\n        op.win.read(fileSize - op.chunkSize, op.chunkSize, readUntilFoundCallback);\n    }\n\n    function readCentralDirectoryComplete() {\n        var buffer = op.win.buffer;\n        var pos = op.lastBufferPosition;\n        try {\n            centralDirectory = new CentralDirectoryHeader();\n            centralDirectory.read(buffer.slice(pos, pos + consts.ENDHDR));\n            centralDirectory.headerOffset = op.win.position + pos;\n            if (centralDirectory.commentLength)\n                that.comment = buffer.slice(pos + consts.ENDHDR,\n                    pos + consts.ENDHDR + centralDirectory.commentLength).toString();\n            else\n                that.comment = null;\n            that.entriesCount = centralDirectory.volumeEntries;\n            that.centralDirectory = centralDirectory;\n            if (centralDirectory.volumeEntries === consts.EF_ZIP64_OR_16 && centralDirectory.totalEntries === consts.EF_ZIP64_OR_16\n                || centralDirectory.size === consts.EF_ZIP64_OR_32 || centralDirectory.offset === consts.EF_ZIP64_OR_32) {\n                readZip64CentralDirectoryLocator();\n            } else {\n                op = {};\n                readEntries();\n            }\n        } catch (err) {\n            that.emit('error', err);\n        }\n    }\n\n    function readZip64CentralDirectoryLocator() {\n        var length = consts.ENDL64HDR;\n        if (op.lastBufferPosition > length) {\n            op.lastBufferPosition -= length;\n            readZip64CentralDirectoryLocatorComplete();\n        } else {\n            op = {\n                win: op.win,\n                totalReadLength: length,\n                minPos: op.win.position - length,\n                lastPos: op.win.position,\n                chunkSize: op.chunkSize,\n                firstByte: consts.ENDL64SIGFIRST,\n                sig: consts.ENDL64SIG,\n                complete: readZip64CentralDirectoryLocatorComplete\n            };\n            op.win.read(op.lastPos - op.chunkSize, op.chunkSize, readUntilFoundCallback);\n        }\n    }\n\n    function readZip64CentralDirectoryLocatorComplete() {\n        var buffer = op.win.buffer;\n        var locHeader = new CentralDirectoryLoc64Header();\n        locHeader.read(buffer.slice(op.lastBufferPosition, op.lastBufferPosition + consts.ENDL64HDR));\n        var readLength = fileSize - locHeader.headerOffset;\n        op = {\n            win: op.win,\n            totalReadLength: readLength,\n            minPos: locHeader.headerOffset,\n            lastPos: op.lastPos,\n            chunkSize: op.chunkSize,\n            firstByte: consts.END64SIGFIRST,\n            sig: consts.END64SIG,\n            complete: readZip64CentralDirectoryComplete\n        };\n        op.win.read(fileSize - op.chunkSize, op.chunkSize, readUntilFoundCallback);\n    }\n\n    function readZip64CentralDirectoryComplete() {\n        var buffer = op.win.buffer;\n        var zip64cd = new CentralDirectoryZip64Header();\n        zip64cd.read(buffer.slice(op.lastBufferPosition, op.lastBufferPosition + consts.END64HDR));\n        that.centralDirectory.volumeEntries = zip64cd.volumeEntries;\n        that.centralDirectory.totalEntries = zip64cd.totalEntries;\n        that.centralDirectory.size = zip64cd.size;\n        that.centralDirectory.offset = zip64cd.offset;\n        that.entriesCount = zip64cd.volumeEntries;\n        op = {};\n        readEntries();\n    }\n\n    function readEntries() {\n        op = {\n            win: new FileWindowBuffer(fd),\n            pos: centralDirectory.offset,\n            chunkSize: chunkSize,\n            entriesLeft: centralDirectory.volumeEntries\n        };\n        op.win.read(op.pos, Math.min(chunkSize, fileSize - op.pos), readEntriesCallback);\n    }\n\n    function readEntriesCallback(err, bytesRead) {\n        if (err || !bytesRead)\n            return that.emit('error', err || 'Entries read error');\n        var\n            buffer = op.win.buffer,\n            bufferPos = op.pos - op.win.position,\n            bufferLength = buffer.length,\n            entry = op.entry;\n        try {\n            while (op.entriesLeft > 0) {\n                if (!entry) {\n                    entry = new ZipEntry();\n                    entry.readHeader(buffer, bufferPos);\n                    entry.headerOffset = op.win.position + bufferPos;\n                    op.entry = entry;\n                    op.pos += consts.CENHDR;\n                    bufferPos += consts.CENHDR;\n                }\n                var entryHeaderSize = entry.fnameLen + entry.extraLen + entry.comLen;\n                var advanceBytes = entryHeaderSize + (op.entriesLeft > 1 ? consts.CENHDR : 0);\n                if (bufferLength - bufferPos < advanceBytes) {\n                    op.win.moveRight(chunkSize, readEntriesCallback, bufferPos);\n                    op.move = true;\n                    return;\n                }\n                entry.read(buffer, bufferPos);\n                if (!config.skipEntryNameValidation) {\n                    entry.validateName();\n                }\n                if (entries)\n                    entries[entry.name] = entry;\n                that.emit('entry', entry);\n                op.entry = entry = null;\n                op.entriesLeft--;\n                op.pos += entryHeaderSize;\n                bufferPos += entryHeaderSize;\n            }\n            that.emit('ready');\n        } catch (err) {\n            that.emit('error', err);\n        }\n    }\n\n    function checkEntriesExist() {\n        if (!entries)\n            throw new Error('storeEntries disabled');\n    }\n\n    Object.defineProperty(this, 'ready', { get: function() { return ready; } });\n\n    this.entry = function(name) {\n        checkEntriesExist();\n        return entries[name];\n    };\n\n    this.entries = function() {\n        checkEntriesExist();\n        return entries;\n    };\n\n    this.stream = function(entry, callback) {\n        return this.openEntry(entry, function(err, entry) {\n            if (err)\n                return callback(err);\n            var offset = dataOffset(entry);\n            var entryStream = new EntryDataReaderStream(fd, offset, entry.compressedSize);\n            if (entry.method === consts.STORED) {\n            } else if (entry.method === consts.DEFLATED || entry.method === consts.ENHANCED_DEFLATED) {\n                entryStream = entryStream.pipe(zlib.createInflateRaw());\n            } else {\n                return callback('Unknown compression method: ' + entry.method);\n            }\n            if (canVerifyCrc(entry))\n                entryStream = entryStream.pipe(new EntryVerifyStream(entryStream, entry.crc, entry.size));\n            callback(null, entryStream);\n        }, false);\n    };\n\n    this.entryDataSync = function(entry) {\n        var err = null;\n        this.openEntry(entry, function(e, en) {\n            err = e;\n            entry = en;\n        }, true);\n        if (err)\n            throw err;\n        var\n            data = new Buffer(entry.compressedSize),\n            bytesRead;\n        new FsRead(fd, data, 0, entry.compressedSize, dataOffset(entry), function(e, br) {\n            err = e;\n            bytesRead = br;\n        }).read(true);\n        if (err)\n            throw err;\n        if (entry.method === consts.STORED) {\n        } else if (entry.method === consts.DEFLATED || entry.method === consts.ENHANCED_DEFLATED) {\n            data = zlib.inflateRawSync(data);\n        } else {\n            throw new Error('Unknown compression method: ' + entry.method);\n        }\n        if (data.length !== entry.size)\n            throw new Error('Invalid size');\n        if (canVerifyCrc(entry)) {\n            var verify = new CrcVerify(entry.crc, entry.size);\n            verify.data(data);\n        }\n        return data;\n    };\n\n    this.openEntry = function(entry, callback, sync) {\n        if (typeof entry === 'string') {\n            checkEntriesExist();\n            entry = entries[entry];\n            if (!entry)\n                return callback('Entry not found');\n        }\n        if (!entry.isFile)\n            return callback('Entry is not file');\n        if (!fd)\n            return callback('Archive closed');\n        var buffer = new Buffer(consts.LOCHDR);\n        new FsRead(fd, buffer, 0, buffer.length, entry.offset, function(err) {\n            if (err)\n                return callback(err);\n            var readEx;\n            try {\n                entry.readDataHeader(buffer);\n                if (entry.encrypted) {\n                    readEx = 'Entry encrypted';\n                }\n            } catch (ex) {\n                readEx = ex\n            }\n            callback(readEx, entry);\n        }).read(sync);\n    };\n\n    function dataOffset(entry) {\n        return entry.offset + consts.LOCHDR + entry.fnameLen + entry.extraLen;\n    }\n\n    function canVerifyCrc(entry) {\n        // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written\n        return (entry.flags & 0x8) != 0x8;\n    }\n\n    function extract(entry, outPath, callback) {\n        that.stream(entry, function (err, stm) {\n            if (err) {\n                callback(err);\n            } else {\n                var fsStm, errThrown;\n                stm.on('error', function(err) {\n                    errThrown = err;\n                    if (fsStm) {\n                        stm.unpipe(fsStm);\n                        fsStm.close(function () {\n                            callback(err);\n                        });\n                    }\n                });\n                fs.open(outPath, 'w', function(err, fdFile) {\n                    if (err)\n                        return callback(err || errThrown);\n                    if (errThrown) {\n                        fs.close(fd, function() {\n                            callback(errThrown);\n                        });\n                        return;\n                    }\n                    fsStm = fs.createWriteStream(outPath, { fd: fdFile });\n                    fsStm.on('finish', function() {\n                        that.emit('extract', entry, outPath);\n                        if (!errThrown)\n                            callback();\n                    });\n                    stm.pipe(fsStm);\n                });\n            }\n        });\n    }\n\n    function createDirectories(baseDir, dirs, callback) {\n        if (!dirs.length)\n            return callback();\n        var dir = dirs.shift();\n        dir = path.join(baseDir, path.join.apply(path, dir));\n        fs.mkdir(dir, function(err) {\n            if (err && err.code !== 'EEXIST')\n                return callback(err);\n            createDirectories(baseDir, dirs, callback);\n        });\n    }\n\n    function extractFiles(baseDir, baseRelPath, files, callback, extractedCount) {\n        if (!files.length)\n            return callback(null, extractedCount);\n        var file = files.shift();\n        var targetPath = path.join(baseDir, file.name.replace(baseRelPath, ''));\n        extract(file, targetPath, function (err) {\n            if (err)\n                return callback(err, extractedCount);\n            extractFiles(baseDir, baseRelPath, files, callback, extractedCount + 1);\n        });\n    }\n\n    this.extract = function(entry, outPath, callback) {\n        var entryName = entry || '';\n        if (typeof entry === 'string') {\n            entry = this.entry(entry);\n            if (entry) {\n                entryName = entry.name;\n            } else {\n                if (entryName.length && entryName[entryName.length - 1] !== '/')\n                    entryName += '/';\n            }\n        }\n        if (!entry || entry.isDirectory) {\n            var files = [], dirs = [], allDirs = {};\n            for (var e in entries) {\n                if (Object.prototype.hasOwnProperty.call(entries, e) && e.lastIndexOf(entryName, 0) === 0) {\n                    var relPath = e.replace(entryName, '');\n                    var childEntry = entries[e];\n                    if (childEntry.isFile) {\n                        files.push(childEntry);\n                        relPath = path.dirname(relPath);\n                    }\n                    if (relPath && !allDirs[relPath] && relPath !== '.') {\n                        allDirs[relPath] = true;\n                        var parts = relPath.split('/').filter(function (f) { return f; });\n                        if (parts.length)\n                            dirs.push(parts);\n                        while (parts.length > 1) {\n                            parts = parts.slice(0, parts.length - 1);\n                            var partsPath = parts.join('/');\n                            if (allDirs[partsPath] || partsPath === '.') {\n                                break;\n                            }\n                            allDirs[partsPath] = true;\n                            dirs.push(parts);\n                        }\n                    }\n                }\n            }\n            dirs.sort(function(x, y) { return x.length - y.length; });\n            if (dirs.length) {\n                createDirectories(outPath, dirs, function (err) {\n                    if (err)\n                        callback(err);\n                    else\n                        extractFiles(outPath, entryName, files, callback, 0);\n                });\n            } else {\n                extractFiles(outPath, entryName, files, callback, 0);\n            }\n        } else {\n            fs.stat(outPath, function(err, stat) {\n                if (stat && stat.isDirectory())\n                    extract(entry, path.join(outPath, path.basename(entry.name)), callback);\n                else\n                    extract(entry, outPath, callback);\n            });\n        }\n    };\n\n    this.close = function(callback) {\n        if (fd) {\n            fs.close(fd, function(err) {\n                fd = null;\n                if (callback)\n                    callback(err);\n            });\n        } else if (callback) {\n            callback();\n        }\n    };\n};\n\nStreamZip.setFs = function(customFs) {\n    fs = customFs;\n};\n\nutil.inherits(StreamZip, events.EventEmitter);\n\n// endregion\n\n// region CentralDirectoryHeader\n\nvar CentralDirectoryHeader = function() {\n};\n\nCentralDirectoryHeader.prototype.read = function(data) {\n    if (data.length != consts.ENDHDR || data.readUInt32LE(0) != consts.ENDSIG)\n        throw new Error('Invalid central directory');\n    // number of entries on this volume\n    this.volumeEntries = data.readUInt16LE(consts.ENDSUB);\n    // total number of entries\n    this.totalEntries = data.readUInt16LE(consts.ENDTOT);\n    // central directory size in bytes\n    this.size = data.readUInt32LE(consts.ENDSIZ);\n    // offset of first CEN header\n    this.offset = data.readUInt32LE(consts.ENDOFF);\n    // zip file comment length\n    this.commentLength = data.readUInt16LE(consts.ENDCOM);\n};\n\n// endregion\n\n// region CentralDirectoryLoc64Header\n\nvar CentralDirectoryLoc64Header = function() {\n};\n\nCentralDirectoryLoc64Header.prototype.read = function(data) {\n    if (data.length != consts.ENDL64HDR || data.readUInt32LE(0) != consts.ENDL64SIG)\n        throw new Error('Invalid zip64 central directory locator');\n    // ZIP64 EOCD header offset\n    this.headerOffset = Util.readUInt64LE(data, consts.ENDSUB);\n};\n\n// endregion\n\n// region CentralDirectoryZip64Header\n\nvar CentralDirectoryZip64Header = function() {\n};\n\nCentralDirectoryZip64Header.prototype.read = function(data) {\n    if (data.length != consts.END64HDR || data.readUInt32LE(0) != consts.END64SIG)\n        throw new Error('Invalid central directory');\n    // number of entries on this volume\n    this.volumeEntries = Util.readUInt64LE(data, consts.END64SUB);\n    // total number of entries\n    this.totalEntries = Util.readUInt64LE(data, consts.END64TOT);\n    // central directory size in bytes\n    this.size = Util.readUInt64LE(data, consts.END64SIZ);\n    // offset of first CEN header\n    this.offset = Util.readUInt64LE(data, consts.END64OFF);\n};\n\n// endregion\n\n// region ZipEntry\n\nvar ZipEntry = function() {\n};\n\nZipEntry.prototype.readHeader = function(data, offset) {\n    // data should be 46 bytes and start with \"PK 01 02\"\n    if (data.length < offset + consts.CENHDR || data.readUInt32LE(offset) != consts.CENSIG) {\n        throw new Error('Invalid entry header');\n    }\n    // version made by\n    this.verMade = data.readUInt16LE(offset + consts.CENVEM);\n    // version needed to extract\n    this.version = data.readUInt16LE(offset + consts.CENVER);\n    // encrypt, decrypt flags\n    this.flags = data.readUInt16LE(offset + consts.CENFLG);\n    // compression method\n    this.method = data.readUInt16LE(offset + consts.CENHOW);\n    // modification time (2 bytes time, 2 bytes date)\n    this.time = data.readUInt32LE(offset + consts.CENTIM);\n    // uncompressed file crc-32 value\n    this.crc = data.readUInt32LE(offset + consts.CENCRC);\n    // compressed size\n    this.compressedSize = data.readUInt32LE(offset + consts.CENSIZ);\n    // uncompressed size\n    this.size = data.readUInt32LE(offset + consts.CENLEN);\n    // filename length\n    this.fnameLen = data.readUInt16LE(offset + consts.CENNAM);\n    // extra field length\n    this.extraLen = data.readUInt16LE(offset + consts.CENEXT);\n    // file comment length\n    this.comLen = data.readUInt16LE(offset + consts.CENCOM);\n    // volume number start\n    this.diskStart = data.readUInt16LE(offset + consts.CENDSK);\n    // internal file attributes\n    this.inattr = data.readUInt16LE(offset + consts.CENATT);\n    // external file attributes\n    this.attr = data.readUInt32LE(offset + consts.CENATX);\n    // LOC header offset\n    this.offset = data.readUInt32LE(offset + consts.CENOFF);\n};\n\nZipEntry.prototype.readDataHeader = function(data) {\n    // 30 bytes and should start with \"PK\\003\\004\"\n    if (data.readUInt32LE(0) != consts.LOCSIG) {\n        throw new Error('Invalid local header');\n    }\n    // version needed to extract\n    this.version = data.readUInt16LE(consts.LOCVER);\n    // general purpose bit flag\n    this.flags = data.readUInt16LE(consts.LOCFLG);\n    // compression method\n    this.method = data.readUInt16LE(consts.LOCHOW);\n    // modification time (2 bytes time ; 2 bytes date)\n    this.time = data.readUInt32LE(consts.LOCTIM);\n    // uncompressed file crc-32 value\n    this.crc = data.readUInt32LE(consts.LOCCRC) || this.crc;\n    // compressed size\n    var compressedSize = data.readUInt32LE(consts.LOCSIZ);\n    if (compressedSize && compressedSize !== consts.EF_ZIP64_OR_32) {\n        this.compressedSize = compressedSize;\n    }\n    // uncompressed size\n    var size = data.readUInt32LE(consts.LOCLEN);\n    if (size && size !== consts.EF_ZIP64_OR_32) {\n        this.size = size;\n    }\n    // filename length\n    this.fnameLen = data.readUInt16LE(consts.LOCNAM);\n    // extra field length\n    this.extraLen = data.readUInt16LE(consts.LOCEXT);\n};\n\nZipEntry.prototype.read = function(data, offset) {\n    this.name = data.slice(offset, offset += this.fnameLen).toString();\n    var lastChar = data[offset - 1];\n    this.isDirectory = (lastChar == 47) || (lastChar == 92);\n\n    if (this.extraLen) {\n        this.readExtra(data, offset);\n        offset += this.extraLen;\n    }\n    this.comment = this.comLen ? data.slice(offset, offset + this.comLen).toString() : null;\n};\n\nZipEntry.prototype.validateName = function() {\n    if (/\\\\|^\\w+:|^\\/|(^|\\/)\\.\\.(\\/|$)/.test(this.name)) {\n        throw new Error('Malicious entry: ' + this.name);\n    }\n};\n\nZipEntry.prototype.readExtra = function(data, offset) {\n    var signature, size, maxPos = offset + this.extraLen;\n    while (offset < maxPos) {\n        signature = data.readUInt16LE(offset);\n        offset += 2;\n        size = data.readUInt16LE(offset);\n        offset += 2;\n        if (consts.ID_ZIP64 === signature) {\n            this.parseZip64Extra(data, offset, size);\n        }\n        offset += size;\n    }\n};\n\nZipEntry.prototype.parseZip64Extra = function(data, offset, length) {\n    if (length >= 8 && this.size === consts.EF_ZIP64_OR_32) {\n        this.size = Util.readUInt64LE(data, offset);\n        offset += 8; length -= 8;\n    }\n    if (length >= 8 && this.compressedSize === consts.EF_ZIP64_OR_32) {\n        this.compressedSize = Util.readUInt64LE(data, offset);\n        offset += 8; length -= 8;\n    }\n    if (length >= 8 && this.offset === consts.EF_ZIP64_OR_32) {\n        this.offset = Util.readUInt64LE(data, offset);\n        offset += 8; length -= 8;\n    }\n    if (length >= 4 && this.diskStart === consts.EF_ZIP64_OR_16) {\n        this.diskStart = data.readUInt32LE(offset);\n        // offset += 4; length -= 4;\n    }\n};\n\nObject.defineProperty(ZipEntry.prototype, 'encrypted', {\n    get: function() { return (this.flags & consts.FLG_ENTRY_ENC) == consts.FLG_ENTRY_ENC; }\n});\n\nObject.defineProperty(ZipEntry.prototype, 'isFile', {\n    get: function() { return !this.isDirectory; }\n});\n\n// endregion\n\n// region FsRead\n\nvar FsRead = function(fd, buffer, offset, length, position, callback) {\n    this.fd = fd;\n    this.buffer = buffer;\n    this.offset = offset;\n    this.length = length;\n    this.position = position;\n    this.callback = callback;\n    this.bytesRead = 0;\n    this.waiting = false;\n};\n\nFsRead.prototype.read = function(sync) {\n    if (StreamZip.debug) {\n        console.log('read', this.position, this.bytesRead, this.length, this.offset);\n    }\n    this.waiting = true;\n    var err;\n    if (sync) {\n        try {\n            var bytesRead = fs.readSync(this.fd, this.buffer, this.offset + this.bytesRead,\n                this.length - this.bytesRead, this.position + this.bytesRead);\n        } catch (e) {\n            err = e;\n        }\n        this.readCallback(sync, err, err ? bytesRead : null);\n    } else {\n        fs.read(this.fd, this.buffer, this.offset + this.bytesRead,\n            this.length - this.bytesRead, this.position + this.bytesRead,\n            this.readCallback.bind(this, sync));\n    }\n};\n\nFsRead.prototype.readCallback = function(sync, err, bytesRead) {\n    if (typeof bytesRead === 'number')\n        this.bytesRead += bytesRead;\n    if (err || !bytesRead || this.bytesRead === this.length) {\n        this.waiting = false;\n        return this.callback(err, this.bytesRead);\n    } else {\n        this.read(sync);\n    }\n};\n\n// endregion\n\n// region FileWindowBuffer\n\nvar FileWindowBuffer = function(fd) {\n    this.position = 0;\n    this.buffer = new Buffer(0);\n\n    var fsOp = null;\n\n    this.checkOp = function() {\n        if (fsOp && fsOp.waiting)\n            throw new Error('Operation in progress');\n    };\n\n    this.read = function(pos, length, callback) {\n        this.checkOp();\n        if (this.buffer.length < length)\n            this.buffer = new Buffer(length);\n        this.position = pos;\n        fsOp = new FsRead(fd, this.buffer, 0, length, this.position, callback).read();\n    };\n\n    this.expandLeft = function(length, callback) {\n        this.checkOp();\n        this.buffer = Buffer.concat([new Buffer(length), this.buffer]);\n        this.position -= length;\n        if (this.position < 0)\n            this.position = 0;\n        fsOp = new FsRead(fd, this.buffer, 0, length, this.position, callback).read();\n    };\n\n    this.expandRight = function(length, callback) {\n        this.checkOp();\n        var offset = this.buffer.length;\n        this.buffer = Buffer.concat([this.buffer, new Buffer(length)]);\n        fsOp = new FsRead(fd, this.buffer, offset, length, this.position + offset, callback).read();\n    };\n\n    this.moveRight = function(length, callback, shift) {\n        this.checkOp();\n        if (shift) {\n            this.buffer.copy(this.buffer, 0, shift);\n        } else {\n            shift = 0;\n        }\n        this.position += shift;\n        fsOp = new FsRead(fd, this.buffer, this.buffer.length - shift, shift, this.position + this.buffer.length - shift, callback).read();\n    };\n};\n\n// endregion\n\n// region EntryDataReaderStream\n\nvar EntryDataReaderStream = function(fd, offset, length) {\n    stream.Readable.prototype.constructor.call(this);\n    this.fd = fd;\n    this.offset = offset;\n    this.length = length;\n    this.pos = 0;\n    this.readCallback = this.readCallback.bind(this);\n};\n\nutil.inherits(EntryDataReaderStream, stream.Readable);\n\nEntryDataReaderStream.prototype._read = function(n) {\n    var buffer = new Buffer(Math.min(n, this.length - this.pos));\n    if (buffer.length) {\n        fs.read(this.fd, buffer, 0, buffer.length, this.offset + this.pos, this.readCallback);\n    } else {\n        this.push(null);\n    }\n};\n\nEntryDataReaderStream.prototype.readCallback = function(err, bytesRead, buffer) {\n    this.pos += bytesRead;\n    if (err) {\n        this.emit('error', err);\n        this.push(null);\n    } else if (!bytesRead) {\n        this.push(null);\n    } else {\n        if (bytesRead !== buffer.length)\n            buffer = buffer.slice(0, bytesRead);\n        this.push(buffer);\n    }\n};\n\n// endregion\n\n// region EntryVerifyStream\n\nvar EntryVerifyStream = function(baseStm, crc, size) {\n    stream.Transform.prototype.constructor.call(this);\n    this.verify = new CrcVerify(crc, size);\n    var that = this;\n    baseStm.on('error', function(e) {\n        that.emit('error', e);\n    });\n};\n\nutil.inherits(EntryVerifyStream, stream.Transform);\n\nEntryVerifyStream.prototype._transform = function(data, encoding, callback) {\n    var err;\n    try {\n        this.verify.data(data);\n    } catch (e) {\n        err = e;\n    }\n    callback(err, data);\n};\n\n// endregion\n\n// region CrcVerify\n\nvar CrcVerify = function(crc, size) {\n    this.crc = crc;\n    this.size = size;\n    this.state = {\n        crc: ~0,\n        size: 0\n    };\n};\n\nCrcVerify.prototype.data = function(data) {\n    var crcTable = CrcVerify.getCrcTable();\n    var crc = this.state.crc, off = 0, len = data.length;\n    while (--len >= 0)\n        crc = crcTable[(crc ^ data[off++]) & 0xff] ^ (crc >>> 8);\n    this.state.crc = crc;\n    this.state.size += data.length;\n    if (this.state.size >= this.size) {\n        var buf = new Buffer(4);\n        buf.writeInt32LE(~this.state.crc & 0xffffffff, 0);\n        crc = buf.readUInt32LE(0);\n        if (crc !== this.crc)\n            throw new Error('Invalid CRC');\n        if (this.state.size !== this.size)\n            throw new Error('Invalid size');\n    }\n};\n\nCrcVerify.getCrcTable = function() {\n    var crcTable = CrcVerify.crcTable;\n    if (!crcTable) {\n        CrcVerify.crcTable = crcTable = [];\n        var b = new Buffer(4);\n        for (var n = 0; n < 256; n++) {\n            var c = n;\n            for (var k = 8; --k >= 0; )\n                if ((c & 1) != 0)  { c = 0xedb88320 ^ (c >>> 1); } else { c = c >>> 1; }\n            if (c < 0) {\n                b.writeInt32LE(c, 0);\n                c = b.readUInt32LE(0);\n            }\n            crcTable[n] = c;\n        }\n    }\n    return crcTable;\n};\n\n// endregion\n\n// region Util\n\nvar Util = {\n    readUInt64LE: function(buffer, offset) {\n        return (buffer.readUInt32LE(offset + 4) * 0x0000000100000000) + buffer.readUInt32LE(offset);\n    }\n};\n\n// endregion\n\n// region exports\n\nmodule.exports = StreamZip;\n\n// endregion\n"],"sourceRoot":""}